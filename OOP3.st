Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'isInterface behavesLike'!!MyObject class methodsFor: 'class variables' stamp: 'SBK 12/15/2019 20:33'!behavesLike	^ self instVarNamed: 'behavesLike'! !!MyObject class methodsFor: 'class variables' stamp: 'SBK 12/15/2019 20:31'!isInterface	^ self instVarNamed: 'isInterface'! !!MyObject class methodsFor: 'subclass creation' stamp: 'SBK 12/16/2019 03:47'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames:    classVarNames poolDictionaries: poolDictionaries category:aCategoryName	"modified initialization message for creating anew class as a sub class of an existing class (the receiver)."	^self subclass: aSubclassName		isInterface: false		behavesLike: {}		instanceVariableNames: instVarNames 		classVariableNames: classVarNames 		poolDictionaries: poolDictionaries 		category:aCategoryName! !!MyObject class methodsFor: 'subclass creation' stamp: 'SBK 12/17/2019 01:53'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category:aCategoryName	"modified initialization message for creating anew class as a sub class of an existing class (the receiver)."	| newSubclass i |		"make sure that interface inherits directly from MyObject"	( (self ~= MyObject) & (isInterface = true) ) ifTrue:		[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].		( (isInterface = true) & (instVarNames ~= '') ) ifTrue:		[AssertionFailure signal: 'Interfaces can not have state!!'].		"make sure that a class doesn't inherit from an interface"	( (self isInterface = true) & (isInterface  = false) ) ifTrue:			[AssertionFailure signal: 'Classes can not derive from an interface!!'].		i := 1.	( i <= aCollection size )	ifTrue: [		"iterate the objects given for 'behavesLike'. if any of them is not of type MyObject or is not an interface, throw"		"( (aCollection at:i) isKindOf: Object) ifFalse: 			[AssertionFailure signal: 'Can not behave like a non-interface!!']."  "check if neccessary - problematic check"		((aCollection at: i) isInterface)  ifFalse: 			[AssertionFailure signal: 'Can not behave like a non-interface!!'].		].			"define the subclass based on the method in the superclass that defines the subclass method"	newSubclass := super subclass: aSubclassName							instanceVariableNames: instVarNames							classVariableNames: classVarNames 							poolDictionaries: poolDictionaries 							category:aCategoryName.		"to init the new class fields, we'll use instVarNamed:put"	(newSubclass) instVarNamed: 'isInterface' put: isInterface.	(newSubclass) instVarNamed: 'behavesLike' put: aCollection.		i := 1.	( i <= aCollection size )	ifTrue: [		"iterate the methodDict of the element and add to the methodDict of the subclass"		(aCollection at: i) methodDictionary associationsDo:   			 [ :assoc | newSubclass methodDictionary at: assoc key put: assoc value ].	].		Transcript show: '**ClassB methodDictionary (After):', String crlf.	newSubclass methodDictionary associationsDo:   		[:assoc | Transcript show: assoc value asString, String crlf].	Transcript show: newSubclass.		^(newSubclass new).! !!MyObject class methodsFor: 'compiling' stamp: 'as 12/14/2019 22:36'!compile: aSourceCode where: anOrderedCollection	|lineTokens numberOfArgs pred args temp updatedCode i errorstring t|		lineTokens := aSourceCode findTokens: (String with: Character cr).		numberOfArgs := (lineTokens at: 1) occurrencesOf: $:.			"checks the number of args at the first line"		pred := numberOfArgs = (anOrderedCollection size).		pred ifFalse: [ AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!' ].		temp := lineTokens at:1.	"get first line"		temp := temp copyWithRegex: '[a-zA-Z0-9]*\:' matchesReplacedWith: ''.	"get only args from first line"		args := temp findTokens: (String with: Character space).  		"put every arg seperated by space in a collection"		temp := ''.	"reset the temp string"		i:=1.		[i <= args size.] whileTrue: [		t := (anOrderedCollection at:i).		pred := ((anOrderedCollection at:i) isNil).	"checks if arg can be any type"		pred ifTrue: [i:= i+1].			"if yes skip type checking"		pred ifFalse: [			errorstring := ' ifFalse: [ AssertionFailure signal: ''Type mismatch!! Argument ' , i , ' should be ' , (anOrderedCollection at: i) ,''' ].'. "makes the string for if isKindof is false"				temp := temp , (Character cr) , '[', (args at:i) , ' isKindOf: ' ,(anOrderedCollection at: i) , '.]' , errorstring.   "creates a string checking the types"			i:=i+1.			].		].		updatedCode := ''.		updatedCode := (lineTokens at: 1) , (Character cr)  , (lineTokens at: 2) , temp.					"puts first three lines of the new code"		i:=3.		[i <= lineTokens size.] whileTrue: [		updatedCode := updatedCode , (Character cr) , (lineTokens at: i).								"puts the rest of the code"		i:=i+1.		].	^self compile: updatedCode notifying: nil! !