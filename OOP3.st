Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'isInterface behavesLike'!!MyObject class methodsFor: 'class variables' stamp: 'as 12/19/2019 02:56'!behavesLike	| behaveSet currentClass |	behaveSet := Set new.	currentClass := self.	(currentClass = MyObject) ifTrue: [^behaveSet.].										"if this is Myobject return empty set"	(currentClass isInterface) ifTrue: [behaveSet add: (self).].							"iterface behaves like himself"	currentClass := currentClass superclass.												"get the superclass"	[ currentClass ~= MyObject .] whileTrue: [												"until we reach my object"		(currentClass behavesLike) collect: [												"get the superclass behaves set"			:IX | behaveSet add: IX.														"and add each to the current set"		].			currentClass := currentClass superclass.	].     (self instVarNamed: 'behavesLike') collect: [					 :IX | currentClass := IX.															"for each interface in behaveslike"		(IX behavesLike) collect: [ 														"get interface behavesLike set"			:IY | behaveSet add: IY.														"and add each element to current set"			]. 						].	^behaveSet.		! !!MyObject class methodsFor: 'class variables' stamp: 'SBK 12/15/2019 20:31'!isInterface	^ self instVarNamed: 'isInterface'! !!MyObject class methodsFor: 'private' stamp: 'SBK 12/19/2019 01:28'!isMethodDefault: selector"receives a method selector and it's code and determines if it's a default method"	| pred code regex lineTokens size |		"make sure that this is called from an interface"	(self isInterface) ifFalse:		[^ false.].		"make sure that the selector starts with 'default' "	regex := 'default' asRegex.	pred := regex matchesPrefix: selector.	pred ifFalse:		[^ false.].		"make sure that the method is not empty"	code := self decompile: selector.	lineTokens := (code asString) findTokens: (String with: Character cr).		"check if the method only contains the selector, args and returns self \\\\\ NOT SURE IF THIS IS A MUST \\\\\\\	size := lineTokens size.	pred := ( (size = 2) & ( (lineTokens at: size) = '	^ self') ).	pred ifTrue:		[^ false]."		"if we got here, the method is not empty and the selector starts with 'default' "	^ true.! !!MyObject class methodsFor: 'private' stamp: 'as 12/18/2019 19:58'!isMethodNotDefaultWithBody: code"receives a method selector and it's code and determines if it's a default method"	| pred regex lineTokens size |		"make sure that this is called from an interface	(self isInterface) ifFalse:		[^ false.]."		"make sure that the method is not empty"	lineTokens := (code) findTokens: (String with: Character cr).		"make sure that the selector starts with 'default'"	regex := 'default' asRegex.	pred := regex matchesPrefix: (lineTokens at: 1).	pred ifTrue:		[^ false.].		"check if the method only contains the selector, args and returns self"	size := lineTokens size.	pred :=  (size = 1).	pred ifTrue:		[^ false].		"if we got here, the method is not empty and the selector doesnt starts with 'default' "	^ true.! !!MyObject class methodsFor: 'private' stamp: 'as 12/19/2019 01:36'!isNotInterface	|pred|	pred:= self instVarNamed: 'isInterface'.	pred ifTrue: [^false.].	^true.! !!MyObject class methodsFor: 'subclass creation' stamp: 'SBK 12/18/2019 18:49'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames:    classVarNames poolDictionaries: poolDictionaries category:aCategoryName	"modified initialization message for creating anew class as a sub class of an existing class (the receiver)."	| newClass |	 newClass := (ClassBuilder new)	superclass: self		subclass: aSubclassName		instanceVariableNames: instVarNames 		classVariableNames: classVarNames 		poolDictionaries: poolDictionaries 		category:aCategoryName.	(newClass) instVarNamed: 'isInterface' put: false.	(newClass) instVarNamed: 'behavesLike' put: {}.	^newClass.! !!MyObject class methodsFor: 'subclass creation' stamp: 'SBK 12/18/2019 23:15'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category:aCategoryName	"modified initialization message for creating anew class as a sub class of an existing class (the receiver)."	| newSubclass i code pred |		"make sure that interface inherits directly from MyObject"	( (self ~= MyObject) & (isInterface = true) ) ifTrue:		[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].		"make sure that interface doesnt have a state"	( (isInterface = true) & (instVarNames ~= '') ) ifTrue:		[AssertionFailure signal: 'Interfaces can not have state!!'].		"make sure that a class doesn't inherit from an interface"	( (self isInterface = true) & (isInterface  = false) ) ifTrue:			[AssertionFailure signal: 'Classes can not derive from an interface!!'].		i := 1.	( i <= aCollection size )	ifTrue: [		"iterate the objects given for 'behavesLike'. if any of them is not of type MyObject or is not an interface, throw"		"( (aCollection at:i) isKindOf: Object) ifFalse: 			[AssertionFailure signal: 'Can not behave like a non-interface!!']." 			 "check if neccessary - problematic check"		((aCollection at: i) isInterface)  ifFalse: 			[AssertionFailure signal: 'Can not behave like a non-interface!!'].		].			"define the subclass based on the method in the superclass that defines the subclass method"	newSubclass := self subclass: aSubclassName							instanceVariableNames: instVarNames							classVariableNames: classVarNames 							poolDictionaries: poolDictionaries 							category:aCategoryName.		"to init the new class fields, we'll use instVarNamed:put"	(newSubclass) instVarNamed: 'isInterface' put: isInterface.	(newSubclass) instVarNamed: 'behavesLike' put: aCollection.		i := 1.	( i <= aCollection size )	ifTrue: [		"iterate the methodDict of the element and add to the methodDict of the subclass"		(aCollection at: i) methodDictionary associationsDo:					"failed attempts:"   			"[ :assoc | newSubclass methodDictionary at: assoc key put: assoc key ]."		"[:assoc | selector := (assoc key). (newSubclass) recompile: (selector) from: (aCollection at:i).]."		"[:assoc | ((newSubclass) addSelector:(assoc key) withMethod: (assoc value)).]."				[:assoc |			"check if the method is default. if it is, add it to the methods dictionary"			pred := (aCollection at: i) isMethodDefault: (assoc key).			pred ifTrue: 				[code := (aCollection at: i) decompile: (assoc key). 				(newSubclass) compile: code asString.].		].	].	^(newSubclass).! !!MyObject class methodsFor: 'compiling' stamp: 'as 12/18/2019 19:53'!compile: code 			(self isInterface) ifTrue: [ 															"check if trying to complite method for interface"		(self isMethodNotDefaultWithBody: code) ifTrue: [									"if the method isn't default and has no body error"			^AssertionFailure signal:'Interfaces are not allowed to have methods that define behavior!!'.].		 ].	^self compile: code notifying: nil! !!MyObject class methodsFor: 'compiling' stamp: 'as 12/18/2019 00:42'!compile: aSourceCode where: anOrderedCollection	| lineTokens numberOfArgs pred args temp updatedCode i errorstring t |	lineTokens := aSourceCode findTokens: (String with: Character cr).	numberOfArgs := (lineTokens at: 1) occurrencesOf: $:.									"checks the number of args at the first line"	pred := numberOfArgs = (anOrderedCollection size).	pred ifFalse: [ AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!!!' ].		pred := numberOfArgs = 0.	"check if no arguments"	pred ifTrue: [ ^self compile: aSourceCode notifying: nil ].								"if no arguments compile the code"			temp := lineTokens at:1.	"get first line"	temp := temp copyWithRegex: '[^\s^\:]*\:' matchesReplacedWith: ''.						"get only args from first line"		args := temp findTokens: (String with: Character space).  								"put every arg seperated by space in a collection"	temp := ''.		"reset the temp string"	i := 1.	[ i <= args size. ] whileTrue: [		t := (anOrderedCollection at:i).		pred := ((anOrderedCollection at:i) isNil).	"checks if arg can be any type"		pred ifTrue: [ i:= i+1 ].		"if it can be any type then skip type checking"		pred ifFalse: [			errorstring := ' ifFalse: [ AssertionFailure signal: ''Type mismatch!!!! Argument ' , i , ' should be ' , (anOrderedCollection at: i) ,''' ].'. "makes the string for if isKindof is false"				temp := temp , (Character cr) , '[', (args at:i) , ' isKindOf: ' ,(anOrderedCollection at: i) , '.]' , errorstring. 	  "creates a string checking the types"			i := i+1.			].		].		pred := ((lineTokens at: 2) endsWith:'|') & ((lineTokens at: 2) startsWith:'|').		"true if there are local variables"	updatedCode := ''.	pred ifTrue: [ 		updatedCode := (lineTokens at: 1) , (Character cr), (lineTokens at: 2) , temp.		"puts first three lines of the new code"		i := 3.																				" if there are local vars, we will continue from the third line and not the second"		].	pred ifFalse: [		updatedCode := (lineTokens at: 1) , temp.											"puts first two lines of the new code"		i := 2.		].			[i <= lineTokens size.] whileTrue: [		updatedCode := updatedCode , (Character cr) , (lineTokens at: i).					"puts the rest of the code"		i := i+1.		].	^self compile: updatedCode notifying: nil! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'as 12/19/2019 15:02'!ambiguities	| behaveSet ambiguites methodsNumImpl |	behaveSet := self behavesLike.															"get behaves like set"	methodsNumImpl := Dictionary new.														"creates dicionary from method name -> to number of implementions"	behaveSet do: [ 																		"for each interface in behaves like"		:X | (((X) methodDictionary) keys) do: [											"get it's methods"			:Y | methodsNumImpl at:Y put: ((methodsNumImpl at: Y ifAbsent: [0] ) +1).		"add each method to dic, if exists increase number of impl by one"			].		 ].		ambiguites := SortedCollection new.													methodsNumImpl keysAndValuesDo: [														"go over the methods"		:aKey :aValue | (aValue > 1) ifTrue: [ambiguites add: aKey.].						"add every methods that has more than 1 implementation"	].	^ambiguites.		! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'as 12/19/2019 13:20'!isImplemented	| interfaceMethods classMethods currentClass predContains pred classesOnlySet|	(self isInterface) ifFalse: [ AssertionFailure signal: (self asString) , ' is not an interface!!'. ].	interfaceMethods := Set new.	pred := false.	(self behavesLike) collect: [															"get the behaveslike set of current interface"		 :X | (X methodDictionary) keys collect: [											"get the methods of each interface in behaveslike"			:Y | (interfaceMethods add: Y).].												"add each method to interfaceMethods set"		].	classesOnlySet := (MyObject withAllSubclasses) asSet.									"get all MyObject subclasses"	classesOnlySet := classesOnlySet select: [ :X | (X isNotInterface) ].					"filter so that only classes that aren't interfaces will stay in the set"	classesOnlySet do: [																	"iterate over the subclasses set"		:X | currentClass := X.		classMethods := Set new.															"create a new classMethods set for this specific class"		(currentClass methodDictionary) keys collect: [										"get the methods of currentclass"			:Y | (classMethods add: Y). ].													"add each method to classMethods set"		[ currentClass ~= MyObject.] whileTrue: [			currentClass := currentClass superclass.			(currentClass methodDictionary) keys collect: [									"get the methods of superclass of currentclass"			:Y | (classMethods add: Y). ].													"add each method to classMethods set"		].		pred := true.																		"for every class iterated, we will set pred to be true, and if we won't find a method then false"		((X behavesLike) includes: self) ifFalse: [pred := false.].							"if class doesnt behave like an interface it cannot implement it"				interfaceMethods do: [ :Z | 																predContains := (classMethods includes: Z).									"check for every method in interfaceMethods"				predContains ifFalse: [ pred := false. ]. 									"if a class doesnt contain - false"										].		pred ifTrue: [^true.].																"if pred is true no method was missing so return true"	].	^false.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'as 12/19/2019 15:10'!isKindOf: aClassOrInterface	| pred currentClass |	pred := false.	currentClass:=self.	[currentClass ~= MyObject] whileTrue: [							(currentClass = aClassOrInterface) ifTrue: [pred := true.].							"check if current class is same as aClassOrInterface if true , pred is true"		currentClass := currentClass superclass.											"get currentclass superclass"	].	(currentClass = aClassOrInterface) ifTrue: [pred := true.].								"check if aClassOrInterface is myobject , if yes pred is true"	pred ifTrue: [^true.].		pred := ((self behavesLike) includes: aClassOrInterface).								"check if self behaves like aClassOrInterface , if yes pred is true"	pred ifTrue: [^true.].	^false.	! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'as 12/19/2019 15:24'!new	| methodsToImpl methodsImpl pred currentSelf |	(self isInterface) ifTrue: [AssertionFailure signal: 'Interfaces can not be instantiated!!'].	methodsToImpl := Set new.	(self behavesLike) collect: [															"get behaves like set"		 :X | ((X) methodDictionary) keys do: [												"get the methods that certain interface implements"			:Y | methodsToImpl add: Y.														"add every method to the methods that need to be implemented"			].	].	methodsImpl := Set new.		currentSelf := self.	[currentSelf ~= MyObject] whileTrue: [													"while current class is not object"		(currentSelf methodDictionary) keys do: [											"get class methods"				:Y | methodsImpl add: Y.													"add every method to method implemented"				].		currentSelf := currentSelf superclass.												"get the superclass"	].	(currentSelf methodDictionary) keys do: [												"get class methods FOR MYOBJECT"				:Y | methodsImpl add: Y.													"add every method to method implemented FOR MYOBJECT"				].					pred:=true.	(methodsToImpl size > 0) ifTrue:[														"check if there are any methods that require implemention"	methodsToImpl do: [																:X | (methodsImpl includes: X) ifFalse: [pred := false.].							"if a method is not implemented , pred will be false"		].	].	pred ifTrue: [^super new].	pred ifFalse: [AssertionFailure signal:'Can not instantiate an Abstract class!!'.].! !