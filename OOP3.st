Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'isInterface behavesLike'!!MyObject class methodsFor: 'class variables' stamp: 'SBK 12/15/2019 20:33'!behavesLike	^ self instVarNamed: 'behavesLike'! !!MyObject class methodsFor: 'class variables' stamp: 'SBK 12/15/2019 20:31'!isInterface	^ self instVarNamed: 'isInterface'! !!MyObject class methodsFor: 'private' stamp: 'SBK 12/18/2019 03:03'!isMethodDefault: selector with: method"receives a method selector and it's code and determines if it's a default method"	| pred code regex lineTokens size |		"make sure that this is called from an interface"	(self isInterface) ifFalse:		[^ false.].		"make sure that the selector starts with 'default' "	regex := 'default' asRegex.	pred := regex matchesPrefix: selector.	pred ifFalse:		[^ false.].		"make sure that the method is not empty"	code := self decompile: selector.	lineTokens := (code asString) findTokens: (String with: Character cr).		"check if the method only contains the selector, args and returns self"	size := lineTokens size.	pred := ( (size = 2) & ( (lineTokens at: size) = '	^ self') ).	pred ifTrue:		[^ false].		"if we got here, the method is not empty and the selector starts with 'default' "	^ true.! !!MyObject class methodsFor: 'subclass creation' stamp: 'SBK 12/16/2019 03:47'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames:    classVarNames poolDictionaries: poolDictionaries category:aCategoryName	"modified initialization message for creating anew class as a sub class of an existing class (the receiver)."	^self subclass: aSubclassName		isInterface: false		behavesLike: {}		instanceVariableNames: instVarNames 		classVariableNames: classVarNames 		poolDictionaries: poolDictionaries 		category:aCategoryName! !!MyObject class methodsFor: 'subclass creation' stamp: 'SBK 12/18/2019 02:51'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category:aCategoryName	"modified initialization message for creating anew class as a sub class of an existing class (the receiver)."	| newSubclass i code pred |		"make sure that interface inherits directly from MyObject"	( (self ~= MyObject) & (isInterface = true) ) ifTrue:		[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].		"make sure that interface doesnt have a state"	( (isInterface = true) & (instVarNames ~= '') ) ifTrue:		[AssertionFailure signal: 'Interfaces can not have state!!'].		"make sure that a class doesn't inherit from an interface"	( (self isInterface = true) & (isInterface  = false) ) ifTrue:			[AssertionFailure signal: 'Classes can not derive from an interface!!'].		i := 1.	( i <= aCollection size )	ifTrue: [		"iterate the objects given for 'behavesLike'. if any of them is not of type MyObject or is not an interface, throw"		"( (aCollection at:i) isKindOf: Object) ifFalse: 			[AssertionFailure signal: 'Can not behave like a non-interface!!']."  "check if neccessary - problematic check"		((aCollection at: i) isInterface)  ifFalse: 			[AssertionFailure signal: 'Can not behave like a non-interface!!'].		].			"define the subclass based on the method in the superclass that defines the subclass method"	newSubclass := super subclass: aSubclassName							instanceVariableNames: instVarNames							classVariableNames: classVarNames 							poolDictionaries: poolDictionaries 							category:aCategoryName.		"to init the new class fields, we'll use instVarNamed:put"	(newSubclass) instVarNamed: 'isInterface' put: isInterface.	(newSubclass) instVarNamed: 'behavesLike' put: aCollection.		i := 1.	( i <= aCollection size )	ifTrue: [		"iterate the methodDict of the element and add to the methodDict of the subclass"		(aCollection at: i) methodDictionary associationsDo:					"failed attempts:"   			"[ :assoc | newSubclass methodDictionary at: assoc key put: assoc key ]."		"[:assoc | selector := (assoc key). (newSubclass) recompile: (selector) from: (aCollection at:i).]."		"[:assoc | ((newSubclass) addSelector:(assoc key) withMethod: (assoc value)).]."				[:assoc |			"check if the method is default. if it is, add it to the methods dictionary"			pred := (aCollection at: i) isMethodDefault: (assoc key) with: (assoc value).			pred ifTrue: 				[code := (aCollection at: i) decompile: (assoc key). 				(newSubclass) compile: code asString.].		].	].	^(newSubclass new).! !!MyObject class methodsFor: 'compiling' stamp: 'SBK 12/18/2019 00:42'!compile: aSourceCode where: anOrderedCollection	| lineTokens numberOfArgs pred args temp updatedCode i errorstring t |	lineTokens := aSourceCode findTokens: (String with: Character cr).	numberOfArgs := (lineTokens at: 1) occurrencesOf: $:.			"checks the number of args at the first line"	pred := numberOfArgs = (anOrderedCollection size).	pred ifFalse: [ AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!!!' ].		pred := numberOfArgs = 0.	"check if no arguments"	pred ifTrue: [ ^self compile: aSourceCode notifying: nil ].	"if no arguments compile the code"			temp := lineTokens at:1.	"get first line"	temp := temp copyWithRegex: '[^\s^\:]*\:' matchesReplacedWith: ''.	"get only args from first line"		args := temp findTokens: (String with: Character space).  		"put every arg seperated by space in a collection"	temp := ''.		"reset the temp string"	i := 1.	[ i <= args size. ] whileTrue: [		t := (anOrderedCollection at:i).		pred := ((anOrderedCollection at:i) isNil).	"checks if arg can be any type"		pred ifTrue: [ i:= i+1 ].		"if it can be any type then skip type checking"		pred ifFalse: [			errorstring := ' ifFalse: [ AssertionFailure signal: ''Type mismatch!!!! Argument ' , i , ' should be ' , (anOrderedCollection at: i) ,''' ].'. "makes the string for if isKindof is false"				temp := temp , (Character cr) , '[', (args at:i) , ' isKindOf: ' ,(anOrderedCollection at: i) , '.]' , errorstring. 	  "creates a string checking the types"			i := i+1.			].		].		pred := ((lineTokens at: 2) endsWith:'|') & ((lineTokens at: 2) startsWith:'|').		"true if there are local variables"	updatedCode := ''.	pred ifTrue: [ 		updatedCode := (lineTokens at: 1) , (Character cr), (lineTokens at: 2) , temp.		"puts first three lines of the new code"		i := 3.		" if there are local vars, we will continue from the third line and not the second"		].	pred ifFalse: [		updatedCode := (lineTokens at: 1) , temp.		"puts first two lines of the new code"		i := 2.		].			[i <= lineTokens size.] whileTrue: [		updatedCode := updatedCode , (Character cr) , (lineTokens at: i).		"puts the rest of the code"		i := i+1.		].	^self compile: updatedCode notifying: nil! !